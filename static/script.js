// Generated by CoffeeScript 1.3.3
(function() {
  var Board, board, connect, myName, replay, send, theirName, ws,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  ws = board = myName = theirName = void 0;

  connect = function() {
    ws = new WebSocket("ws://" + document.location.host + "/ws" + document.location.pathname);
    ws.onopen = function() {
      return $("#connection-status").text("Connected! Waiting for another player...");
    };
    ws.onerror = function(e) {
      console.log("error", e);
      return ws = void 0;
    };
    ws.onclose = function(e) {
      console.log("close", e);
      return ws = void 0;
    };
    return ws.onmessage = function(d) {
      var data, message;
      data = JSON.parse(d.data);
      if (data.ping) {
        return send({
          ping: "ping"
        });
      } else if (data.myName) {
        myName = data.myName;
        return theirName = data.theirName;
      } else if (data.hasEnded) {
        message = data.playerOne.hasLost && data.playerTwo.hasLost ? "You both lost at the same time." : data[myName].hasLost ? "You lost!" : "You won!";
        $("#connection-status").text(message).slideDown();
        $("#replay").fadeIn();
        return ws.close();
      } else if (data.playerOne) {
        board || (board = new Board(data));
        $("#connection-status").slideUp();
        $("#grid").fadeIn();
        return board.update(data);
      }
    };
  };

  connect();

  $("#replay").click(replay = function() {
    if (ws !== void 0) {
      return;
    }
    $("#connection-status").text("Connecting...");
    board.clear();
    connect();
    return $("#replay").fadeOut();
  });

  Board = (function() {

    function Board(data) {
      this.clickHandler = __bind(this.clickHandler, this);

      var elem, grid, height, width, x, y, _i, _j;
      width = data.width, height = data.height;
      grid = $("#grid");
      this.domElements = {};
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
        for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
          elem = $("<div>", {
            "class": "cell"
          });
          elem.data({
            x: x,
            y: y
          });
          this.domElements[[x, y]] = elem;
          grid.append(elem);
        }
        grid.append($("<div>", {
          style: "clear: both;"
        }));
      }
      grid.on('touchstart', function(evt) {
        return evt.preventDefault();
      });
      grid.on('touchend', this.clickHandler);
      grid.click(this.clickHandler);
      this.formerTails = [];
    }

    Board.prototype.update = function(data) {
      var me, myTail, pos, theirTail, them, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      me = data[myName];
      them = data[theirName];
      myTail = me.position[me.position.length - 1];
      theirTail = them.position[them.position.length - 1];
      if (this.formerTails.length === 0) {
        _ref = me.position;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pos = _ref[_i];
          this.domElements[pos].toggleClass("me", true);
        }
        _ref1 = them.position;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          pos = _ref1[_j];
          this.domElements[pos].toggleClass("them", true);
        }
      } else {
        _ref2 = this.formerTails;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          pos = _ref2[_k];
          if ((_ref3 = pos.toString()) !== myTail.toString() && _ref3 !== theirTail.toString()) {
            this.domElements[pos].removeClass("me them");
          }
        }
        this.domElements[me.position[0]].removeClass("food").addClass("me");
        this.domElements[them.position[0]].removeClass("food").addClass("them");
        _ref4 = data.food;
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          pos = _ref4[_l];
          this.domElements[pos].addClass("food");
        }
      }
      _ref5 = me.position, this.head = _ref5[0], this.tail = 2 <= _ref5.length ? __slice.call(_ref5, 1) : [];
      return this.formerTails = [myTail, theirTail];
    };

    Board.prototype.clear = function() {
      var elem, pos, _ref, _results;
      _ref = this.domElements;
      _results = [];
      for (pos in _ref) {
        elem = _ref[pos];
        _results.push(elem.removeClass("food me them"));
      }
      return _results;
    };

    Board.prototype.heading = function() {
      return [this.head[0] - this.tail[0][0], this.head[1] - this.tail[0][1]];
    };

    Board.prototype.clickHandler = function(evt) {
      var dx, dy, heading, moreX, x, y, _ref;
      evt.preventDefault();
      _ref = $(evt.target).data(), x = _ref.x, y = _ref.y;
      heading = this.heading();
      dx = x - this.head[0];
      dy = y - this.head[1];
      moreX = Math.abs(dx) > Math.abs(dy);
      if (heading[0] && dy) {
        send({
          heading: dy > 0 ? 'down' : 'up'
        });
        if (moreX && heading[0] * dx < 0) {
          send({
            heading: dx > 0 ? 'right' : 'left'
          });
        }
      } else if (heading[1] && dx) {
        send({
          heading: dx > 0 ? 'right' : 'left'
        });
        if (!moreX && heading[1] * dy < 0) {
          send({
            heading: dy > 0 ? 'down' : 'up'
          });
        }
      }
      return false;
    };

    return Board;

  })();

  send = function(m) {
    if (ws !== void 0) {
      return ws.send(JSON.stringify(m));
    }
  };

  $("body").keydown(function(e) {
    var heading;
    heading = (function() {
      switch (e.keyCode) {
        case 37:
        case 72:
          return 'left';
        case 38:
        case 75:
          return 'up';
        case 39:
        case 76:
          return 'right';
        case 40:
        case 74:
          return 'down';
      }
    })();
    if (heading !== void 0) {
      send({
        heading: heading
      });
    }
    if (e.keyCode === 13 || e.keyCode === 32) {
      return replay();
    }
  });

}).call(this);
